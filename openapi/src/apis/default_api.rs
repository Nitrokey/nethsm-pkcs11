/*
 * NetHSM
 *
 * All endpoints expect exactly the specified JSON. Additional properties will cause a Bad Request Error (400). All HTTP errors contain a JSON structure with an explanation of type string. All [base64](https://tools.ietf.org/html/rfc4648#section-4) encoded values are Big Endian.
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

#[derive(Clone, Debug)]
pub enum KeysKeyIdCertGetAccept {
    ApplicationXPemFile,
    ApplicationXX509CaCert,
    ApplicationPgpKeys,
}

impl KeysKeyIdCertGetAccept {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::ApplicationXPemFile => "application/x-pem-file",
            Self::ApplicationXX509CaCert => "application/x-x509-ca-cert",
            Self::ApplicationPgpKeys => "application/pgp-keys",
        }
    }

    pub fn is_json(&self) -> bool {
        match self {
            Self::ApplicationXPemFile => false,
            Self::ApplicationXX509CaCert => false,
            Self::ApplicationPgpKeys => false,
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdCertPutBody {
    ApplicationXPemFile(String),
    ApplicationXX509CaCert(String),
    ApplicationPgpKeys(String),
}

impl KeysKeyIdCertPutBody {
    pub fn content_type(&self) -> &'static str {
        match self {
            Self::ApplicationXPemFile(_) => "application/x-pem-file",
            Self::ApplicationXX509CaCert(_) => "application/x-x509-ca-cert",
            Self::ApplicationPgpKeys(_) => "application/pgp-keys",
        }
    }
    pub fn is_json(&self) -> bool {
        match self {
            Self::ApplicationXPemFile(_) => false,
            Self::ApplicationXX509CaCert(_) => false,
            Self::ApplicationPgpKeys(_) => false,
        }
    }
    pub fn get_string(&self) -> String {
        match self {
            Self::ApplicationXPemFile(s) => s.clone(),
            Self::ApplicationXX509CaCert(s) => s.clone(),
            Self::ApplicationPgpKeys(s) => s.clone(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdPutBody {
    ApplicationJson(crate::models::PrivateKey),
    ApplicationXPemFile(String),
}

impl KeysKeyIdPutBody {
    pub fn content_type(&self) -> &'static str {
        match self {
            Self::ApplicationJson(_) => "application/json",
            Self::ApplicationXPemFile(_) => "application/x-pem-file",
        }
    }
    pub fn is_json(&self) -> bool {
        match self {
            Self::ApplicationJson(_) => true,
            Self::ApplicationXPemFile(_) => false,
        }
    }
    pub fn get_string(&self) -> String {
        match self {
            Self::ApplicationJson(_) => "".to_string(),
            Self::ApplicationXPemFile(s) => s.clone(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysPostBody {
    ApplicationJson(crate::models::PrivateKey),
    ApplicationXPemFile(String),
}

impl KeysPostBody {
    pub fn content_type(&self) -> &'static str {
        match self {
            Self::ApplicationJson(_) => "application/json",
            Self::ApplicationXPemFile(_) => "application/x-pem-file",
        }
    }
    pub fn is_json(&self) -> bool {
        match self {
            Self::ApplicationJson(_) => true,
            Self::ApplicationXPemFile(_) => false,
        }
    }
    pub fn get_string(&self) -> String {
        match self {
            Self::ApplicationJson(_) => "".to_string(),
            Self::ApplicationXPemFile(s) => s.clone(),
        }
    }
}

/// struct for typed errors of method [`config_backup_passphrase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigBackupPassphrasePutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logging_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLoggingGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logging_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLoggingPutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_network_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigNetworkGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_network_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigNetworkPutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_time_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTimeGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_time_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTimePutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_tls_cert_pem_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTlsCertPemGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_tls_cert_pem_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTlsCertPemPutError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_tls_csr_pem_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTlsCsrPemPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_tls_generate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTlsGeneratePostError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_tls_public_pem_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigTlsPublicPemGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_unattended_boot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigUnattendedBootGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_unattended_boot_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigUnattendedBootPutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_unlock_passphrase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigUnlockPassphrasePutError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`health_alive_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthAliveGetError {
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`health_ready_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthReadyGetError {
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`health_state_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthStateGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InfoGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_generate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysGeneratePostError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_cert_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdCertDeleteError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_cert_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdCertGetError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_cert_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdCertPutError {
    Status401(),
    Status403(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_csr_pem_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdCsrPemPostError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_decrypt_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdDecryptPostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdDeleteError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_encrypt_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdEncryptPostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdGetError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_public_pem_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdPublicPemGetError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdPutError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_restrictions_tags_tag_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdRestrictionsTagsTagDeleteError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_restrictions_tags_tag_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdRestrictionsTagsTagPutError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_key_id_sign_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysKeyIdSignPostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeysPostError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lock_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metrics_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetricsGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provision_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProvisionPostError {
    Status400(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`random_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RandomPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_backup_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemBackupPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_cancel_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemCancelUpdatePostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_commit_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemCommitUpdatePostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_factory_reset_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemFactoryResetPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemInfoGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_reboot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemRebootPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemRestorePostError {
    Status400(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_shutdown_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemShutdownPostError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`system_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemUpdatePostError {
    Status401(),
    Status403(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlock_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlockPostError {
    Status400(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersGetError {
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersPostError {
    Status400(),
    Status401(),
    Status403(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdDeleteError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdGetError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_passphrase_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdPassphrasePostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdPutError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdTagsGetError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_tags_tag_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdTagsTagDeleteError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_user_id_tags_tag_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdTagsTagPutError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// Update the backup passphrase.
pub async fn config_backup_passphrase_put(
    configuration: &configuration::Configuration,
    backup_passphrase_config: crate::models::BackupPassphraseConfig,
) -> Result<ResponseContent<()>, Error<ConfigBackupPassphrasePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/config/backup-passphrase",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&backup_passphrase_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigBackupPassphrasePutError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get logging configuration. Protocol is always syslog over UDP. Configurable are IP adress and port, log level.
pub async fn config_logging_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::LoggingConfig>, Error<ConfigLoggingGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/logging", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::LoggingConfig =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigLoggingGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure log level and destination.
pub async fn config_logging_put(
    configuration: &configuration::Configuration,
    logging_config: crate::models::LoggingConfig,
) -> Result<ResponseContent<()>, Error<ConfigLoggingPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/logging", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&logging_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigLoggingPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get network configuration. IP address, netmask, router.
pub async fn config_network_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::NetworkConfig>, Error<ConfigNetworkGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/network", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::NetworkConfig =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigNetworkGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure network.
pub async fn config_network_put(
    configuration: &configuration::Configuration,
    network_config: crate::models::NetworkConfig,
) -> Result<ResponseContent<()>, Error<ConfigNetworkPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/network", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&network_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigNetworkPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get system time.
pub async fn config_time_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::TimeConfig>, Error<ConfigTimeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/time", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::TimeConfig =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTimeGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure system time.
pub async fn config_time_put(
    configuration: &configuration::Configuration,
    time_config: crate::models::TimeConfig,
) -> Result<ResponseContent<()>, Error<ConfigTimePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/time", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&time_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTimePutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get certificate for NetHSMs https API.
pub async fn config_tls_cert_pem_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<String>, Error<ConfigTlsCertPemGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/tls/cert.pem", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/x-pem-file";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity = local_var_content.clone();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTlsCertPemGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set certificate for NetHSMs https API e.g. to replace self-signed intital certificate.
pub async fn config_tls_cert_pem_put(
    configuration: &configuration::Configuration,
    body: &str,
) -> Result<ResponseContent<()>, Error<ConfigTlsCertPemPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/tls/cert.pem", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/x-pem-file");
    local_var_req_builder = local_var_req_builder.body(body.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTlsCertPemPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NetHSM certificate signing request e.g. to replace self-signed intital certificate.
pub async fn config_tls_csr_pem_post(
    configuration: &configuration::Configuration,
    distinguished_name: crate::models::DistinguishedName,
) -> Result<ResponseContent<String>, Error<ConfigTlsCsrPemPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/tls/csr.pem", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&distinguished_name);
    let accept_str = "application/x-pem-file";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity = local_var_content.clone();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTlsCsrPemPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generate a new pair of public and private key for NetHSM's https API.
pub async fn config_tls_generate_post(
    configuration: &configuration::Configuration,
    tls_key_generate_request_data: crate::models::TlsKeyGenerateRequestData,
) -> Result<ResponseContent<()>, Error<ConfigTlsGeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/config/tls/generate", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&tls_key_generate_request_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTlsGeneratePostError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get public key for NetHSMs https API.
pub async fn config_tls_public_pem_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<String>, Error<ConfigTlsPublicPemGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/config/tls/public.pem",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/x-pem-file";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity = local_var_content.clone();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigTlsPublicPemGetError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Read unattended boot configuration: is it on or off?
pub async fn config_unattended_boot_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::UnattendedBootConfig>, Error<ConfigUnattendedBootGetError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/config/unattended-boot",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::UnattendedBootConfig =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigUnattendedBootGetError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure unattended boot: switch it on or off (flip the switch).
pub async fn config_unattended_boot_put(
    configuration: &configuration::Configuration,
    unattended_boot_config: crate::models::UnattendedBootConfig,
) -> Result<ResponseContent<()>, Error<ConfigUnattendedBootPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/config/unattended-boot",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&unattended_boot_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigUnattendedBootPutError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the unlock passphrase.
pub async fn config_unlock_passphrase_put(
    configuration: &configuration::Configuration,
    unlock_passphrase_config: crate::models::UnlockPassphraseConfig,
) -> Result<ResponseContent<()>, Error<ConfigUnlockPassphrasePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/config/unlock-passphrase",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&unlock_passphrase_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ConfigUnlockPassphrasePutError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve wether NetHSM is alive (powered up). This corresponds to the state *Locked* or *Unprovisioned*.
pub async fn health_alive_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<HealthAliveGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/health/alive", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: HealthAliveGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve wether NetHSM is alive and ready to take traffic. This corresponds to the state *Operational*.
pub async fn health_ready_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<HealthReadyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/health/ready", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: HealthReadyGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the state of NetHSM.
pub async fn health_state_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::HealthStateData>, Error<HealthStateGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/health/state", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::HealthStateData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: HealthStateGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Information about the vendor and product.
pub async fn info_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::InfoData>, Error<InfoGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/info", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::InfoData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: InfoGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generate a pair of public and private key and store it in NetHSM. KeyID is optional as a parameter and will be generated by NetHSM if not present.
pub async fn keys_generate_post(
    configuration: &configuration::Configuration,
    key_generate_request_data: crate::models::KeyGenerateRequestData,
) -> Result<ResponseContent<()>, Error<KeysGeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/keys/generate", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&key_generate_request_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysGeneratePostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of the identifiers of all keys that are currently stored in NetHSM. Separate requests need to be made to request the individual key data.
pub async fn keys_get(
    configuration: &configuration::Configuration,
    filter: Option<&str>,
) -> Result<ResponseContent<Vec<crate::models::KeyItem>>, Error<KeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/keys", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = filter {
        local_var_req_builder =
            local_var_req_builder.query(&[("filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Vec<crate::models::KeyItem> =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the certificate.
pub async fn keys_key_id_cert_delete(
    configuration: &configuration::Configuration,
    key_id: &str,
) -> Result<ResponseContent<()>, Error<KeysKeyIdCertDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/cert",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdCertDeleteError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve stored certificate. The content-type header will display the media type of the stored data.
pub async fn keys_key_id_cert_get(
    configuration: &configuration::Configuration,
    key_id: &str,
    accept: KeysKeyIdCertGetAccept,
) -> Result<ResponseContent<String>, Error<KeysKeyIdCertGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/cert",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = accept.as_str();
    let is_json = accept.is_json();
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: String = if is_json {
            serde_json::from_str(&local_var_content).map_err(Error::from)?
        } else {
            local_var_content
        };
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdCertGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Store a certificate. Maximum size 1MB. The content-type header provides the media type. Only application/json, application/x-pem-file, application/x-x509-ca-cert, application/octet-stream, text/plain and application/pgp-keys is allowed.
pub async fn keys_key_id_cert_put(
    configuration: &configuration::Configuration,
    key_id: &str,
    body: KeysKeyIdCertPutBody,
) -> Result<ResponseContent<()>, Error<KeysKeyIdCertPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/cert",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let body_json = body.is_json();
    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, body.content_type());

    if body_json {
        local_var_req_builder = local_var_req_builder.json(&body);
    } else {
        local_var_req_builder = local_var_req_builder.body(body.get_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdCertPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a certificate signing request in PEM format.
pub async fn keys_key_id_csr_pem_post(
    configuration: &configuration::Configuration,
    key_id: &str,
    distinguished_name: crate::models::DistinguishedName,
) -> Result<ResponseContent<String>, Error<KeysKeyIdCsrPemPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/csr.pem",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&distinguished_name);
    let accept_str = "application/x-pem-file";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity = local_var_content.clone();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdCsrPemPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Decrypt an encrypted message with the secret key.
pub async fn keys_key_id_decrypt_post(
    configuration: &configuration::Configuration,
    key_id: &str,
    decrypt_request_data: crate::models::DecryptRequestData,
) -> Result<ResponseContent<crate::models::DecryptData>, Error<KeysKeyIdDecryptPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/decrypt",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&decrypt_request_data);
    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::DecryptData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdDecryptPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a pair of public and private key.
pub async fn keys_key_id_delete(
    configuration: &configuration::Configuration,
    key_id: &str,
) -> Result<ResponseContent<()>, Error<KeysKeyIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdDeleteError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Encrypt a message with the secret key.
pub async fn keys_key_id_encrypt_post(
    configuration: &configuration::Configuration,
    key_id: &str,
    encrypt_request_data: crate::models::EncryptRequestData,
) -> Result<ResponseContent<crate::models::EncryptData>, Error<KeysKeyIdEncryptPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/encrypt",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&encrypt_request_data);
    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::EncryptData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdEncryptPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the public key.
pub async fn keys_key_id_get(
    configuration: &configuration::Configuration,
    key_id: &str,
) -> Result<ResponseContent<crate::models::PublicKey>, Error<KeysKeyIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::PublicKey =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve public key in PEM format.
pub async fn keys_key_id_public_pem_get(
    configuration: &configuration::Configuration,
    key_id: &str,
) -> Result<ResponseContent<String>, Error<KeysKeyIdPublicPemGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/public.pem",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/x-pem-file";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity = local_var_content.clone();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdPublicPemGetError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Import a private key into NetHSM and store it under the *KeyID* path. The public key will be automatically derived. The parameters of the key can be passed as a PEM file or a JSON object.
pub async fn keys_key_id_put(
    configuration: &configuration::Configuration,
    key_id: &str,
    body: KeysKeyIdPutBody,
    mechanisms: Option<Vec<crate::models::KeyMechanism>>,
    tags: Option<Vec<String>>,
) -> Result<ResponseContent<()>, Error<KeysKeyIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = mechanisms {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("mechanisms".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "mechanisms",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("tags".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "tags",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let body_json = body.is_json();
    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, body.content_type());

    if body_json {
        local_var_req_builder = local_var_req_builder.json(&body);
    } else {
        local_var_req_builder = local_var_req_builder.body(body.get_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a tag from the authorized set
pub async fn keys_key_id_restrictions_tags_tag_delete(
    configuration: &configuration::Configuration,
    tag: &str,
    key_id: &str,
) -> Result<ResponseContent<()>, Error<KeysKeyIdRestrictionsTagsTagDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/restrictions/tags/{Tag}",
        local_var_configuration.base_path,
        Tag = crate::apis::urlencode(tag),
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdRestrictionsTagsTagDeleteError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a tag to the authorized set
pub async fn keys_key_id_restrictions_tags_tag_put(
    configuration: &configuration::Configuration,
    tag: &str,
    key_id: &str,
) -> Result<ResponseContent<()>, Error<KeysKeyIdRestrictionsTagsTagPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/restrictions/tags/{Tag}",
        local_var_configuration.base_path,
        Tag = crate::apis::urlencode(tag),
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdRestrictionsTagsTagPutError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sign a message with the secret key.
pub async fn keys_key_id_sign_post(
    configuration: &configuration::Configuration,
    key_id: &str,
    sign_request_data: crate::models::SignRequestData,
) -> Result<ResponseContent<crate::models::SignData>, Error<KeysKeyIdSignPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/keys/{KeyID}/sign",
        local_var_configuration.base_path,
        KeyID = crate::apis::urlencode(key_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&sign_request_data);
    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::SignData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysKeyIdSignPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Import a private key into NetHSM and let NetHSM generate a KeyID. The public key will be automatically derived. The parameters of the key can be passed as a PEM file or a JSON object.
pub async fn keys_post(
    configuration: &configuration::Configuration,
    body: KeysPostBody,
    mechanisms: Option<Vec<crate::models::KeyMechanism>>,
    tags: Option<Vec<String>>,
) -> Result<ResponseContent<()>, Error<KeysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/keys", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = mechanisms {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("mechanisms".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "mechanisms",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("tags".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "tags",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let body_json = body.is_json();
    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, body.content_type());

    if body_json {
        local_var_req_builder = local_var_req_builder.json(&body);
    } else {
        local_var_req_builder = local_var_req_builder.body(body.get_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: KeysPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Brings an *Operational* NetHSM into *Locked* state.
pub async fn lock_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<LockPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/lock", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: LockPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get metrics. Precondition: NetHSM is *Operational* and a **R-Metrics** can be authenticated.
pub async fn metrics_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<serde_json::Value>, Error<MetricsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metrics", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: serde_json::Value =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: MetricsGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Initial provisioning, only available in *Unprovisioned* state.
pub async fn provision_post(
    configuration: &configuration::Configuration,
    provision_request_data: crate::models::ProvisionRequestData,
) -> Result<ResponseContent<()>, Error<ProvisionPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/provision", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&provision_request_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: ProvisionPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve cryptographically strong random bytes from NetHSM. Precondition: NetHSM is *Operational* and a **R-Operator** can be authenticated.
pub async fn random_post(
    configuration: &configuration::Configuration,
    random_request_data: crate::models::RandomRequestData,
) -> Result<ResponseContent<crate::models::RandomData>, Error<RandomPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/random", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&random_request_data);
    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::RandomData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: RandomPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Back up the key store to a backup file.
pub async fn system_backup_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemBackupPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/backup", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemBackupPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel update of NetHSM software.
pub async fn system_cancel_update_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemCancelUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/cancel-update", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemCancelUpdatePostError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Commit update of NetHSM software.
pub async fn system_commit_update_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemCommitUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/commit-update", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemCommitUpdatePostError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset NetHSM to factory settings.
pub async fn system_factory_reset_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemFactoryResetPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/factory-reset", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemFactoryResetPostError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get detailed system information, including firmware, system, and hardware version.
pub async fn system_info_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<crate::models::SystemInfo>, Error<SystemInfoGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/info", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::SystemInfo =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemInfoGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reboot NetHSM.
pub async fn system_reboot_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemRebootPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/reboot", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemRebootPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore the key store and user store from a backup file. If NetHSM is *Unprovisioned*, then the configuration is restored.
pub async fn system_restore_post(
    configuration: &configuration::Configuration,
    backup_passphrase: &str,
    body: &str,
    system_time: Option<String>,
) -> Result<ResponseContent<()>, Error<SystemRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/restore", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder =
        local_var_req_builder.query(&[("backupPassphrase", &backup_passphrase.to_string())]);
    if let Some(ref local_var_str) = system_time {
        local_var_req_builder =
            local_var_req_builder.query(&[("systemTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/octet-stream");
    local_var_req_builder = local_var_req_builder.body(body.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemRestorePostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Shut down NetHSM.
pub async fn system_shutdown_post(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<()>, Error<SystemShutdownPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/shutdown", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemShutdownPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update NetHSM software.
pub async fn system_update_post(
    configuration: &configuration::Configuration,
    body: &str,
) -> Result<ResponseContent<crate::models::SystemUpdateData>, Error<SystemUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/system/update", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/octet-stream");
    local_var_req_builder = local_var_req_builder.body(body.to_string());
    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::SystemUpdateData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: SystemUpdatePostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Brings a *Locked* NetHSM into *Operational* state.
pub async fn unlock_post(
    configuration: &configuration::Configuration,
    unlock_request_data: crate::models::UnlockRequestData,
) -> Result<ResponseContent<()>, Error<UnlockPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unlock", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&unlock_request_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UnlockPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of all user ids that have accounts on NetHSM.
pub async fn users_get(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<Vec<crate::models::UserItem>>, Error<UsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/users", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Vec<crate::models::UserItem> =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new user on NetHSM. The user-ID is generated by NetHSM.
pub async fn users_post(
    configuration: &configuration::Configuration,
    user_post_data: crate::models::UserPostData,
) -> Result<ResponseContent<()>, Error<UsersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/users", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&user_post_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersPostError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a user from keyfender.
pub async fn users_user_id_delete(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<ResponseContent<()>, Error<UsersUserIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdDeleteError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get user info: name and role.
pub async fn users_user_id_get(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<ResponseContent<crate::models::UserData>, Error<UsersUserIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: crate::models::UserData =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the passphrase.
pub async fn users_user_id_passphrase_post(
    configuration: &configuration::Configuration,
    user_id: &str,
    user_passphrase_post_data: crate::models::UserPassphrasePostData,
) -> Result<ResponseContent<()>, Error<UsersUserIdPassphrasePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}/passphrase",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&user_passphrase_post_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdPassphrasePostError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a user on keyfender.
pub async fn users_user_id_put(
    configuration: &configuration::Configuration,
    user_id: &str,
    user_post_data: crate::models::UserPostData,
) -> Result<ResponseContent<()>, Error<UsersUserIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    local_var_req_builder =
        local_var_req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    local_var_req_builder = local_var_req_builder.json(&user_post_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdPutError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of tags set to an Operator user.
pub async fn users_user_id_tags_get(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<ResponseContent<Vec<String>>, Error<UsersUserIdTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}/tags",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let accept_str = "application/json";
    local_var_req_builder = local_var_req_builder.header(reqwest::header::ACCEPT, accept_str);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Vec<String> =
            serde_json::from_str(&local_var_content).map_err(Error::from)?;
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdTagsGetError = serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a tag from the Operator user
pub async fn users_user_id_tags_tag_delete(
    configuration: &configuration::Configuration,
    user_id: &str,
    tag: &str,
) -> Result<ResponseContent<()>, Error<UsersUserIdTagsTagDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}/tags/{Tag}",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id),
        Tag = crate::apis::urlencode(tag)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdTagsTagDeleteError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a tag to the Operator user.
pub async fn users_user_id_tags_tag_put(
    configuration: &configuration::Configuration,
    user_id: &str,
    tag: &str,
) -> Result<ResponseContent<()>, Error<UsersUserIdTagsTagPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/users/{UserID}/tags/{Tag}",
        local_var_configuration.base_path,
        UserID = crate::apis::urlencode(user_id),
        Tag = crate::apis::urlencode(tag)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_headers = local_var_resp.headers().clone();

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    let local_var_content_clone = local_var_content.clone();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content_clone,
            entity: (),
            headers: local_var_headers,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: UsersUserIdTagsTagPutError =
            serde_json::from_str(&local_var_content)?;
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
            headers: local_var_headers,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
